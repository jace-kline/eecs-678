# EECS 678 - Lab 5 Report
* Name: Jace Kline
* KUID: 2881618

## Question Answers:
1. For signals such as KILL and STOP, it is important that they are handled directly by the operating system to ensure that some process does not overwrite the signal handler functionality of these unique signals. The KILL and STOP signals must not be overwritten because they are the last line of defense to terminate a "rogue" program. If the programmer were allowed to overwrite these, there would be no guarantees regarding the termination of programs. This would imply that the only way to know a process is terminated would be to shut down the machine. Hence, it is extremely important that the KILL and STOP signals are handled directly by the operating system.
2. There are two main reasons why the pause() system call is superior to using an infinite loop. The first reason is that pause() will block sequential execution only until there is any signal received, but then program execution will continue as normal. Secondly, the return value of pause() indicates the type of signal received. Therefore, we can add logic following a pause() call to get more fine-tuned behavior out of out signal handling. While using an infinite loop without pause(), it requires much more work to detect that a signal has been received/handled, namely because it requires the storage of flag variables that must be updated in the subsequent handler functions.
3. The purpose of masking chosen signals while inside a particular signal handler is that it allows the programmer to ensure that the chosen signals will not initiate their handler functions during the execution of the current signal handler. This is important because oftentimes signal handlers are designed to use global variables and resources that could also be mutated/used in the context of other signal handlers. To ensure proper execution of the signal handler, we want to preserve the state of all the global context as it was upon entry to the handler because the handler often relies on assumptions about this data to execute properly. To prevent the mutation of the global state during the execution of the handler, it is imperative that we mask signals with handlers that also mutate the same global data. Conceptually, this is the same as protecting critical sections or masking interrupts.
4. When we implement the timeout, we do not want to mask the SIGALRM signal because the SIGALRM signal is what is sent to the process upon completion of the timeout to indicate that the timeout has indeed completed. The reception (and non-masking) of the SIGALRM signal following the completion of the timeout is what triggers the signal handler function defined for the SIGALRM signal. If we were to have masked the SIGALRM signal, then the completion of the timeout would not have triggered execution of the handler function and this behavior would not be desired. Hence, we must unmask the SIGALRM signal in our program.
